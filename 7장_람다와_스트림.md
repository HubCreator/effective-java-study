- [아이템42](#아이템42)
- [아이템43](#아이템43)
- [아이템44](#아이템44)
- [아이템45](#아이템45)
- [아이템46](#아이템46)
- [아이템47](#아이템47)
- [아이템48](#아이템48)

## 아이템42

**깃짱**: p.257 `람다는 이름이 없고 문서화도 못한다.` 왜 문서화를 못할까요? 문서화를 하려면 클래스처럼 남아 있어야 하는데 람다는 본체인 함수형 인터페이스의 인스턴스가 익명 클래스처럼 하나의 클래스로 분리되지 않고 한 번 사용되고 사라진다는 의미에서 이렇게 작성했다고 이해했는데 다들 비슷하게 이해하셨나요?

## 아이템43

## 아이템44

**지토**: `Runnable`은 함수형 인터페이스 중 멀티 스레드와 관련된 기능에 사용하는 것이 관례라고 알고 있습니다.     
다만 `Runnable.run()`은 `void run();` 처럼 매우 간단한 인터페이스이다 보니 자주 사용하게 되는 양식입니다.     
그렇다면 멀티 스레드와 완전히 관계가 없는 기능임에도 불구한 상황에서도 `Runnable`을 그대로 사용해도 괜찮을까요?      
아니면 네이밍을 다시 해 주기 위해 새롭게 인터페이스와 메소드 명을 지정해주는 것이 좋을까요?
- **깃짱**: 멀티 스레드 사용한 적이 없어서 이건 첨 알았네요...! ㄷㄷ 저라면 `.run()`이 그래도 익숙하니 사용할 것 같아요 정 이름이 맘에 안들면 그때 새롭게 만들듯...?!!

**레오**: 미션 진행하면서 표준 함수형 인터페이스 사용하신적 있으신가요?? 책에서 람다 코드는 간결해야 한다(3줄 정도)라고 나와있는데 이걸 지키면서 사용해보셨나요?
전 사용해보고 싶은데, 사용 해본 적이 없어서 언제 표준 함수형 인터페이스를 사용해야 할지 모르겠어요. (예외처리 Supplier제외)

**레오**: 마지막에 다중정의를 주의하라고 하면서 ExecutorService의 submit을 예시로 들고 있는데, 아래 코드처럼 정의되어 있습니다~ <br>
`<T> Future<T> submit(Callable<T> task);` <br>
`<T> Future<T> submit(Runnable task, T result);` <br>
`Future<?> submit(Runnable task);` <br>

## 아이템45

## 아이템46

## 아이템47

## 아이템48
