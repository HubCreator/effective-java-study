- [아이템42](#아이템42)
- [아이템43](#아이템43)
- [아이템44](#아이템44)
- [아이템45](#아이템45)
- [아이템46](#아이템46)
- [아이템47](#아이템47)
- [아이템48](#아이템48)

## 아이템42

**깃짱**: p.257 `람다는 이름이 없고 문서화도 못한다.` 왜 문서화를 못할까요?     
문서화를 하려면 클래스처럼 남아 있어야 하는데 람다는 본체인 함수형 인터페이스의 인스턴스가 익명 클래스처럼 하나의 클래스로 분리되지 않고 한 번 사용되고 사라진다는 의미에서 이렇게 작성했다고 이해했는데 다들 비슷하게 이해하셨나요?

## 아이템43

**깃짱**: 질문은 없어서 요약 한줄 남기겠슴니당 메서드 참조는 람다보다 간결하게 만들 수 있는데, 꼭 그런건 아니니 살펴보고 쓰자

## 아이템44

**지토**: `Runnable`은 함수형 인터페이스 중 멀티 스레드와 관련된 기능에 사용하는 것이 관례라고 알고 있습니다.     
다만 `Runnable.run()`은 `void run();` 처럼 매우 간단한 인터페이스이다 보니 자주 사용하게 되는 양식입니다.     
그렇다면 멀티 스레드와 완전히 관계가 없는 기능임에도 불구한 상황에서도 `Runnable`을 그대로 사용해도 괜찮을까요?      
아니면 네이밍을 다시 해 주기 위해 새롭게 인터페이스와 메소드 명을 지정해주는 것이 좋을까요?
- **깃짱**: 멀티 스레드 사용한 적이 없어서 이건 첨 알았네요...! ㄷㄷ 저라면 `Runnable`에서 유용하게 쓸 수 있는 다른 `default` 메서드가 있다면 써야 하니깐 어쩔 수 없이 그대로 가고, 없는데 이름이 영 맘에 안든다면 재정의 할 것 같아요. 근데 `run()`이라는 메서드명 자체가 너무 익숙해서 별 일 없어도 쓸 것 같은데 이런것까지 신경쓰면서 해야할까요???
 
**레오**: 미션 진행하면서 표준 함수형 인터페이스 사용하신적 있으신가요?? 책에서 람다 코드는 간결해야 한다(3줄 정도)라고 나와있는데 이걸 지키면서 사용해보셨나요?    
전 사용해보고 싶은데, 사용 해본 적이 없어서 언제 표준 함수형 인터페이스를 사용해야 할지 모르겠어요. (예외처리 Supplier제외)     
- **깃짱**: 저는 예전에 브릿지 겜에서 [이런식](https://github.com/eunkeeee/java-bridge/blob/final/src/main/java/bridge/controller/MainController.java)으로 써봤어요 지토 따라했던거라 자세한 문의는 @지토    

**레오**: 마지막에 다중정의를 주의하라고 하면서 ExecutorService의 submit을 예시로 들고 있는데, 아래 코드처럼 정의되어 있습니다~ <br>
`<T> Future<T> submit(Callable<T> task);` <br>
`<T> Future<T> submit(Runnable task, T result);` <br>
`Future<?> submit(Runnable task);` <br>
- **깃짱**: 진짜 호출할 때마다 헷갈리게 생기긴 했네요 ㅋㅎㅋㅎㅋ 

## 아이템45

**깃짱**: p.269 `스트림 API는 메서드 연쇄를 지원하는 플루언트 API이다.`라는 말이 있슴니다. 플루언트가 뭔가 찾아봤는데 `산문처럼` 읽히는 그런건가봐요 유창..?    
저는 이거를 예를 들어서 `Position add(Position position)` 이런 시그니처의 메서드는 호출한 후에도 결과가 더해진 `Position`이 다시 반환되니, 연달아 점을 계속 찍어서    
`position.add(new Position(3)).multiply(new Position(45))` 뭐 이런식으로 쓸 수 있잖아요?    
이런 느낌으로 이해했는데 동의하시나요?

## 아이템46

**깃짱**: 첫 문단에서 `스트림은 그저 또 하나의 API가 아닌, 함수형 프로그래밍에 기초한 패러다임이기 때문이다`라는 말에서 `함수형 프로그래밍`에 기초했다는 말에 대해서 설명해주실 수 있나요??     
저는 함수형 프로그래밍 아직 잘 설명할 수는 없지만, 하나의 함수가 외부에 영향을 주지 않고(=외부 변수를 수정하거나, 상태에 영향을 주지 않고) 예측 가능하고 일관적이게 행동하기 때문에 `함수 또한 하나의 상수처럼 볼 수 있다`로 이해하고 있습니다.    
따라서 함수형 프로그래밍에 기반을 둔 스트림은 자신의 `주 작용`(정해진 대로 하나의 input에 대해서 일관적이고 예측 가능한 output을 내놓는다) 외에 `부 작용`(외부에 영향을 주어 상태를 변화시킨다)을 완전히 없애야 한다고 이해했습니다. 이것이 여기서 말하는 `순수 함수`인 것 같아요!

**깃짱**: p.278의 밑에서부터 다섯 번째 줄에서,   
`그저 축소(reduction) 전략을 캡슐화한 **블랙박스 객체**라고 생각하기 바란다.`에서 `블랙박스 객체`가 잘 이해가 되지 않네요...! 

## 아이템47

**깃짱**: 질문은 없어 요약 => `Collection` 인터페이스는 `Iterable`의 하위 타입이어서 반복을 제공하고, `.stream()` 메서드도 있어서 스트림 생성도 됨. 스트림은 반복을 제공하지 않음. 따라서 기왕이면 둘 다 되는 `Collection`을 반환 타입으로 하고, 정 안되면 + 스트림 파이프라인으로만 쓸 거라고 확신하면 스트림으로 반환하셈 

## 아이템48

**깃짱**: 병렬화는 읽어도 아직 잘 모르겠슴당 좀더 기초공부를 하고 다시 읽어보겠슴당   
동시성 문제를 해결하기 위해서는 안전성, 응답 가능을 신경써야하는데 스트림에서 신경쓸 부분이 있나보군요!
