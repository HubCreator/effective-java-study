- [아이템42](#아이템42)
- [아이템43](#아이템43)
- [아이템44](#아이템44)
- [아이템45](#아이템45)
- [아이템46](#아이템46)
- [아이템47](#아이템47)
- [아이템48](#아이템48)

## 아이템42

## 아이템43

## 아이템44

**지토**: `Runnable`은 함수형 인터페이스 중 멀티 스레드와 관련된 기능에 사용하는 것이 관례라고 알고 있습니다.     
다만 `Runnable.run()`은 `void run();` 처럼 매우 간단한 인터페이스이다 보니 자주 사용하게 되는 양식입니다.     
그렇다면 멀티 스레드와 완전히 관계가 없는 기능임에도 불구한 상황에서도 `Runnable`을 그대로 사용해도 괜찮을까요?      
아니면 네이밍을 다시 해 주기 위해 새롭게 인터페이스와 메소드 명을 지정해주는 것이 좋을까요?

**레오**: 미션 진행하면서 표준 함수형 인터페이스 사용하신적 있으신가요?? 책에서 람다 코드는 간결해야 한다(3줄 정도)라고 나와있는데 이걸 지키면서 사용해보셨나요?
전 사용해보고 싶은데, 사용 해본 적이 없어서 언제 표준 함수형 인터페이스를 사용해야 할지 모르겠어요. (예외처리 Supplier제외)

**레오**: 마지막에 다중정의를 주의하라고 하면서 ExecutorService의 submit을 예시로 들고 있는데, 아래 코드처럼 정의되어 있습니다~ <br>
`<T> Future<T> submit(Callable<T> task);` <br>
`<T> Future<T> submit(Runnable task, T result);` <br>
`Future<?> submit(Runnable task);` <br>

## 아이템45

## 아이템46

## 아이템47

## 아이템48
