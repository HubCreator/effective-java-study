- [아이템15](#아이템15)
- [아이템16](#아이템16)
- [아이템17](#아이템17)
- [아이템18](#아이템18)
- [아이템19](#아이템19)
- [아이템20](#아이템20)
- [아이템21](#아이템21)
- [아이템22](#아이템22)
- [아이템23](#아이템23)
- [아이템24](#아이템24)
- [아이템25](#아이템25)

## 아이템 15

**쥬니**: 이 전에도 나왔던 이야기 같은데, 서로 다른 클래스에서 동일한 상수를 사용한다면 각각에서 `private static`으로 관리하시는지, 하나의 클래스에서 `public static`으로관리하시는지 궁금합니다. 혹은 `enum`을 사용하시기도 하겠죠 !?  
- **깃짱**: 저는 각각 관리합니다. 이 [질문에 대한 답을 한 리뷰](https://github.com/woowacourse/java-chess/pull/516#issuecomment-1478089090)를 염탐중에 봐서, 첨부할게요
        ![image](https://user-images.githubusercontent.com/107979804/227103421-409f27e9-6334-4c91-a637-2fcc0fee3da3.png)
- **민트**: 저는 상수를 도메인적 의미에 맞는 하나의 클래스에서 private static으로 관리하고, 다른 클래스에서 필요로 한다면 상수를 관리하는 클래스에서 값을 반환하는 메서드를 가지는 게 좋지 않나 생각합니다. 상수 역시 도메인이 변경됨에 따라 변경될 여지가 있는 관리대상이라고 생각하기 때문에 하나의 클래스에서 관리하는 것이 좋다고 생각합니다. 

**지토**: `해당 클래스가 표현하는 추상 개념을 완성하는데 꼭 필요한 구성요소로써의 상수라면 public static final 필드로 공개해도 좋다`라고 언급이 되어있는데, 이 예시로는 어떤게 있을까요?

**민트**: `private 멤버를 테스트하기 위해 package-private으로 수정하고, 테스트 코드를 테스트 대상과 같은 패키지에 두어도 된다` 라는 내용이 있습니다. 저는 private 메서드에 대해서는 직접적으로 테스트해주기 보다는, 이를 호출하는 public 메서드를 통해 간접적으로 테스트를 진행해 왔습니다. 여러분은 책에서 말하듯이 테스트를 위해 private 접근 제어자를 default 접근 제어자로 변경할 생각이 있으신가요?
- **이리내**: 저는 민트가 이전에 하던 방식대로 하지 않을까 싶습니다. 메소드명 앞에 public이든 private이든 protected이든 뭔가 하나가 붙어있는게 심신에 안정감이 듭니다ㅋㅋ. r그리고, 테스트 코드와 프로덕션 코드를 같은 패키지에 두는게 좋은건지도 잘 모르겠습니다. 두 종류의 코드 사이에 혼선만 늘어나지 않을까요

**이리내**: [이 블로그](https://hyeon9mak.github.io/Java-dont-use-package-private/)를 보면 현업에서는 `package-private`을 별로 사용하지 않는다 하네요..?

## 아이템 16

**지토**: 해당 아이템을 읽으면서 든 생각인데, `File`이나 `Rank` 같이 원시값을 포장한 객체 비슷하게 쓰고 있는 `enum`의 필드 접근 제어자를 `default`로 설정하고 동일한 패키지에 있는 `Position`같은 클래스에서 바로 접근해도 괜찮은걸까요?

**테오**: 저는 package-private으로 열어도 된다는 말에 공감이 잘 안되는 것 같아요! 패키지는 상대적인 개념이고 결국 패키지에 의존한다는 건 가변적인 정보에 의존한다는 것인데, 이후에 패키지가 변경되지 않는다는 보장이 있을지 궁금하네요..! 물론 Java API야 정적인 라이브러리이므로 거의 변화하지 않아서 package-private으로 열어도 된다고 생각하긴 하지만요..
- 지토: 동의합니다! 그래도 어떤 상황에서 쓸 수 있을지 고민해보면 `팩토리 패턴`같이 각 클래스의 결합도가 확고할 때 사용을 고려해볼 수 있을 것 같습니다. 그래도 이 경우는 `public`으로 열어두는 것을 `package-private`으로 축소하는 느낌이라 그 반대의 경우는 썩 좋지는 않을 것 같습니다...
    
## 아이템 17
**쥬니**: 아래 코드의 결과는 무엇일까요 ?
```java
public class Item17 {
    public static void main(String[] args) {
        StringBuilder sb = new StringBuilder();

        sb.append("test");

        String str1 = sb.toString();
        String str2 = "test";

        System.out.println("str1 == str2 ? " + (str1 == str2)); // true ? false ?
    }
}
```

- **지토**: false가 나올 것 같습니다!
- **깃짱**: 올 지토 돌려보셨나요..?    

![image](https://user-images.githubusercontent.com/107979804/227104006-787fb3ac-59d0-49aa-96d1-d3daf7f08974.png)

왜 이런걸까요...? `StringBuilder`를 생성했을 때 `706`이었다가 `.toString()`을 통해서 `str1`로 만들 때 `834`가 되었고, `str2`는 `835`네요
`StringBuilder.toString()`을 뜯어보면

```java
    @Override
    @HotSpotIntrinsicCandidate
    public String toString() {
        // Create a copy, don't share the array
        return isLatin1() ? StringLatin1.newString(value, 0, count)
                          : StringUTF16.newString(value, 0, count);
    }
```

이렇게 생겼고,
여기서 `StringLatin1.newString()`을 보면

```java
   public static String newString(byte[] val, int index, int len) {
        return new String(Arrays.copyOfRange(val, index, index + len),
                          LATIN1);
    }
```

이렇게 생겼네요...! 
`new String()`으로 생성자를 새로 호출하기 때문에 다른 주소값을 받게 되나봅니다.

**헙크**: JMM이란 무엇일까? 멀티 스레드 프로그래밍에서 어떤 것을 주의해야 할까?

**민트**: `PhoneNumbe와 Complex같은 단순한 값 객체는 항상 불변으로 만들자`라는 내용이 있습니다. 단순한 값 객체는 불변으로 만들어도 잠재적 성능 저하가 크지 않기 때문에 불변 객체를 권장하는 것일까요? 그렇다면 불변 객체로 만들지 말지의 기준 중 하나로 `잠재적 성능 저하가 큰가?`를 떠올릴 수 있을까요?

**지토**: 저는 불변이 너무 어렵습니다...이번 아이템에서는 그냥 무조건 불변을 사용하라는 느낌인데, 불변이 절대적인 가치라고 볼 수 있을까요?
어떠한 관점에서 불변을 적용할지 고민해야 할까요?

**이리내**: 이번 체스게임에서 어떤 팀이 게임할 차례인지 관리하는 부분을 불변으로 사용하신 분 계신가요? 저는 ChessGame 클래스에 turn이라는 가변 필드를 두고 이를 바꾸어주도록 했는데, 다들 어떤 식으로 구현하였는지 궁금합니다! 그리고 혹시 보드를 컨트롤러의 필드에 두신 분이 계시다면, 보드를 초기화하는 것을 컨트롤러의 생성자에서 하셨나요? 저는 뭔가 start라는 명령어가 들어와야 보드를 초기화하는게 자연스러운 것 같은데, 일단 final로 선언해주기위해 생성자에서 하고 있습니다.
- 헙크: 저는 final 키워드를 붙이지 않고, start 명령어가 입력되는 시점에 초기화해주었습니다!
     
## 아이템 18

**쥬니**: 상속이 `콜백` 프레임워크와 어울리지 않는다는 예시는 [이곳](https://stackoverflow.com/questions/28254116/wrapper-classes-are-not-suited-for-callback-frameworks)을 참고하세요 !

**깃짱**: p.120 이 페이지에서 `Properties` 클래스는 `Hashtable`을 컴포지션으로 기능을 위임했다면 좋았을 텐데, 불필요하게 `Hashtable`을 상속해 내부 구현을 불필요하게 노출했다고 하고 있다. `Properties의 인스턴스인 p가 있을 때, p.getProperty(key)와 p.get(key)의 결과가 다를 수 있다`

여기 코드를 `Properties` 클래스에 들어가서 직접 가져왔다.

```java
    public String getProperty(String key) {
        Object oval = map.get(key);
        String sval = (oval instanceof String) ? (String)oval : null;
        Properties defaults;
        return ((sval == null) && ((defaults = this.defaults) != null)) ? defaults.getProperty(key) : sval;
    }
    
        @Override
    public Object get(Object key) {
        return map.get(key);
    }
```

여기서 `.getProperty()`는 기본 동작이고, `.get()`은 상위 클래스로부터 `Override`한 메서드이다.
두 가지 동작이 달라 혼란스러울 수 있다!

**테오**: protected 메소드에 대해 어떻게 생각하세요? 저는 이 아이템을 읽고 나서 protected가 추상화 레벨을 파괴하는 주범으로 생각되는 것 같아요.

**민트**: 상속이 캡슐화를 깨뜨리는 이유에 대해서 어떻게 생각하시나요?

**이리내**: 정리하면, 상속이 캡슐화를 깨뜨리는 이유는, 자식 클래스의 경우에는 `상위 클래스가 구현된 형태에 따라 자식 클래스의 동작이 달라질 수 있다는 것`, 부모 클래스의 경우에는 `protected로 메서드를 공개하는 것`과, `내부 매커니즘을 문서로 남기는 것`(아이템19) 때문일까요?  

**레오**: 예제 코드 18-2조합을 이용한 예제코드에서 ForwardingSet이 Set을 인스턴스 변수로 가지고 있어서 조합이라고 한걸까요? InstrumentedSet은 ForwardingSet을 상속하고 있어서 헷갈리네요...
- **하디**: 내부적으로 Set을 가지고 있어 addAll이 실행되어도 본인의 add를 사용하는게 아니기 때문 아닌가요?

**하디**: 다들 상속또는 조합을 선택하는 자신만의 기준이 있나요?

## 아이템 19
**헙크**: 추상 클래스에서 메서드 바디를 구성해 하위 클래스에서 사용할 수 있도록 제공하려고할 때, 메서드 레벨에 `final`을 붙여야만 하는가?

- 지토:        
![](https://user-images.githubusercontent.com/57691173/227140323-59993aee-ec61-4a61-ab8e-1269e71285ea.png)   
`final` 안붙이고 하위 클래스에서 재정의하는 꼼수를 부려봤는데 이런 피드백을 받은 것으로 보아 이러는 것을 방지하기 위해서 `final`을 붙이는 것이 좋을 것 같습니다. 
- **이리내**: 저도 지토와 같은 꼼수를 부려서 지토와 유사한(?) 피드백을 받았는데요. 추상클래스에서 바디를 구성하고, 이를 하위 클래스에서 오버라이딩으로 메서드를 재정의하게된다면, 추상클래스에서 `완전히 구현되지 않은 상태를 구현됬다고 뻥치는 것`으로 보인다는 느낌의 피드백을 받았습니다. `추상`클래스라는 닉값을 하려면 자식클래스에 따라 동작이 달라질 가능성이 있는 메서드들은 추상메서드로, 그게 아닌 메서드는 final로 선언하는 게 좋을 것 같아요!

**깃짱**: p.125 `상속용 클래스의 생성자는 Override 가능한 메서드를 호출해서는 안된다.`   
![image](https://user-images.githubusercontent.com/107979804/227126292-7306bdce-7ee6-4a15-976d-ffd0b42acc4d.png)


실행 결과가 이렇게 나왔습니다.   


![image](https://user-images.githubusercontent.com/107979804/227126409-bea25ba8-9071-4fdf-91ed-54b0382756cf.png)



저는 출력 결과가 
```
Super 클래스
Sub 클래스
2023-03-23T06:52:25.039807200Z
``` 

일 것이라고 예상했는데, 이 출력 메세지를 본다면,    
`Sub` 클래스의 메서드로 override 된다 => Super 클래스의 생성자 호출 => Sub 클래스의 생성자 호출   
이런 식으로 메서드가 호출되는 걸까요?
- 지토: 그런거 같습니다! `Sub` 클래스를 `new` 키워드를 통해 호출하다보니 `Super` 클래스의 생성자의 `overrideMe()`는 `Sub.overrideMe()`가 될 수 밖에 없다 보니 두 번 호출되는 느낌?인 것 같습니다!
- **하디**: super class의 생성자를 호출하고 그 뒤에 자기 자신의 생성자를 호출하는 걸로 압니다!

## 아이템 20

**지토**: 블랙잭 미션때도 그렇고 지금 체스 미션때도 그렇고 저는 항상 상속을 사용하면 피를 보게 되는 것 같습니다...이번 파트를 읽어보니 상속을 사용하려면 고려해야 할 사항이 많은 것 같은데, 차라리 미션에서는 상속을 후순위로 미뤄두는게 나을까요?
- **테오**: 저도 상속을 사용했다가 3단계에서 갈아엎었는데요!.. 문제 해결 영역에 따라 다른 것 같다고 생각이 들긴 하네요. 만약 체스 게임에서 앞으로 100년 10000년 기물에 대한 움직임 규칙이 변화하지 않는다고 한다면 상속 구조를 사용해도 되지 않을까요? 따라서 미션에서는 사용해도 될 것 같습니다.
- **하디**: 어떠 부분에 피를 보셨는지 얘기를 들어볼 수 있나요? 저는 상속관계가 맞다고 생각해서요

**깃짱**: p.133에서 말하는 추상 클래스로 타입을 정의할 때 따라오는 심각한 제약은 무엇일까요? 추상 클래스 타입을 반환값으로 사용할 수 없다는 문제일까요?
- **민트**: 골격 구현 클래스는 타입을 인터페이스로 정의하고 있습니다. 그리고 130 페이지의 첫 문단, 마지막 문장에서 `인터페이스가 ... 잘 지킨 클래스라면 다른 어떤 클래스를 상속했든 같은 타입으로 취급된다.`라고 하고 있습니다. 이런 내용을 보고 생각했을 때 단일 상속만 지원함으로써 생기는 계층구조를 말하는 것이 아닐까 싶습니다만 잘은 모르겠네요.. 
## 아이템 21
**하디**: p137에서 Collection의 구현체를 아파치 SynchronizedCollection은 동기화 기능을 구현했다고 나옵니다. Collection 인터페이스에 default method르 추가하며 이를 구현한 구현체에서 호출하여 예상치 못한 동작을 할 수 있어 위험하다로 이해하면 될까요? 

**지토**: 전에 네오가 `default method`에 관해 언급한 내용이 이 내용인 것 같습니다! 결국 이것도 자바의 특징 중 하나인 이전 버전과의 호환성을 위한 억지스러운 기능인 느낌이네요..
한 번 정리해봤는데, 피드백 부탁드립니다 ㅎㅎ; 

```
- 코드 복잡성 증가 : `default method`는 클래스에서 재정의할 수 있으므로, 전체적인 애플리케이션 구조에서 특정 인터페이스 구현체가 `default method`를 그대로 사용하는지, 오버라이딩해서 사용하는지 알 수 없음
- 오버라이딩 유무 : 인터페이스의 구현체 입장에서, `default method`를 그대로 사용해야 하는지 아니면 재정의해야할지 판단하기 애매할 수 있음
- API 확장에 대한 제한 : `default method`의 기능을 완전히 대체하는 새로운 기능이 인터페이스에 추가되는 경우 이전 코드는 그대로 `default method`를 사용하므로 확장된 기능에 대해 인식할 수 없어지고, 이로 인해 예기치 않은 동작이 발생하고 이전 버전과의 호환성을 유지하기 어려울 수 있음
- 다중 구현 시 발생할 수 있는 문제 : 인터페이스는 다중 구현이 가능하므로, `default method` 여러 개가 동일한 메소드 시그니처를 가지게 되는 경우 어떠한 `default method`를 사용할지 알 수 없기 때문에 이를 구현체가 오버라이딩해야만 함
```

## 아이템 22
**쥬니**: 정적 import에 대해 어떻게 생각하시나요 ? 어떤 리뷰어들은 이를 사용하는 것이 가독성을 해친다고 이야기 하는데, 여러분들의 생각이 궁금합니다.
## 아이템 23

## 아이템 24
**쥬니**: 미션을 진행하시면서, 중첩 클래스를 사용해보신적이 있나요? 있다면 사용 예시가 궁금합니다.
- 지토: [여기](https://sorjfkrh5078.tistory.com/108)에서 언급된 `Bill Pugh Singleton Implementation`에서 사용해봤습니다. 그리고 빌더 패턴 적용할 때 정도..?

## 아이템 25
