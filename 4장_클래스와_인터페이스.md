- [아이템15](#아이템15)
- [아이템16](#아이템16)
- [아이템17](#아이템17)
- [아이템18](#아이템18)
- [아이템19](#아이템19)
- [아이템20](#아이템20)
- [아이템21](#아이템21)
- [아이템22](#아이템22)
- [아이템23](#아이템23)
- [아이템24](#아이템24)
- [아이템25](#아이템25)

## 아이템 15

**쥬니**: 이 전에도 나왔던 이야기 같은데, 서로 다른 클래스에서 동일한 상수를 사용한다면 각각에서 `private static`으로 관리하시는지, 하나의 클래스에서 `public static`으로관리하시는지 궁금합니다. 혹은 `enum`을 사용하시기도 하겠죠 !?  
- **깃짱**: 저는 각각 관리합니다. 이 [질문에 대한 답을 한 리뷰](https://github.com/woowacourse/java-chess/pull/516#issuecomment-1478089090)를 염탐중에 봐서, 첨부할게요
        ![image](https://user-images.githubusercontent.com/107979804/227103421-409f27e9-6334-4c91-a637-2fcc0fee3da3.png)

**지토**: `해당 클래스가 표현하는 추상 개념을 완성하는데 꼭 필요한 구성요소로써의 상수라면 public static final 필드로 공개해도 좋다`라고 언급이 되어있는데, 이 예시로는 어떤게 있을까요?

## 아이템 16

**지토**: 해당 아이템을 읽으면서 든 생각인데, `File`이나 `Rank` 같이 원시값을 포장한 객체 비슷하게 쓰고 있는 `enum`의 필드 접근 제어자를 `default`로 설정하고 동일한 패키지에 있는 `Position`같은 클래스에서 바로 접근해도 괜찮은걸까요?

**테오**: 저는 package-private으로 열어도 된다는 말에 공감이 잘 안되는 것 같아요! 패키지는 상대적인 개념이고 결국 패키지에 의존한다는 건 가변적인 정보에 의존한다는 것인데, 이후에 패키지가 변경되지 않는다는 보장이 있을지 궁금하네요..! 물론 Java API야 정적인 라이브러리이므로 거의 변화하지 않아서 package-private으로 열어도 된다고 생각하긴 하지만요..

## 아이템 17
**쥬니**: 아래 코드의 결과는 무엇일까요 ?
```java
public class Item17 {
    public static void main(String[] args) {
        StringBuilder sb = new StringBuilder();

        sb.append("test");

        String str1 = sb.toString();
        String str2 = "test";

        System.out.println("str1 == str2 ? " + (str1 == str2)); // true ? false ?
    }
}
```

- **지토**: false가 나올 것 같습니다!
- **깃짱**: 올 지토 돌려보셨나요..?    

![image](https://user-images.githubusercontent.com/107979804/227104006-787fb3ac-59d0-49aa-96d1-d3daf7f08974.png)

왜 이런걸까요...? `StringBuilder`를 생성했을 때 `706`이었다가 `.toString()`을 통해서 `str1`로 만들 때 `834`가 되었고, `str2`는 `835`네요
`StringBuilder.toString()`을 뜯어보면

```java
    @Override
    @HotSpotIntrinsicCandidate
    public String toString() {
        // Create a copy, don't share the array
        return isLatin1() ? StringLatin1.newString(value, 0, count)
                          : StringUTF16.newString(value, 0, count);
    }
```

이렇게 생겼고,
여기서 `StringLatin1.newString()`을 보면

```java
   public static String newString(byte[] val, int index, int len) {
        return new String(Arrays.copyOfRange(val, index, index + len),
                          LATIN1);
    }
```

이렇게 생겼네요...! 
`new String()`으로 생성자를 새로 호출하기 때문에 다른 주소값을 받게 되나봅니다.

**헙크**: JMM이란 무엇일까? 멀티 스레드 프로그래밍에서 어떤 것을 주의해야 할까?

## 아이템 18

**쥬니**: 상속이 `콜백` 프레임워크와 어울리지 않는다는 예시는 [이곳](https://stackoverflow.com/questions/28254116/wrapper-classes-are-not-suited-for-callback-frameworks)을 참고하세요 !

**깃짱**: p.120 이 페이지에서 `Properties` 클래스는 `Hashtable`을 컴포지션으로 기능을 위임했다면 좋았을 텐데, 불필요하게 `Hashtable`을 상속해 내부 구현을 불필요하게 노출했다고 하고 있다. `Properties의 인스턴스인 p가 있을 때, p.getProperty(key)와 p.get(key)의 결과가 다를 수 있다`

여기 코드를 `Properties` 클래스에 들어가서 직접 가져왔다.

```java
    public String getProperty(String key) {
        Object oval = map.get(key);
        String sval = (oval instanceof String) ? (String)oval : null;
        Properties defaults;
        return ((sval == null) && ((defaults = this.defaults) != null)) ? defaults.getProperty(key) : sval;
    }
    
        @Override
    public Object get(Object key) {
        return map.get(key);
    }
```

여기서 `.getProperty()`는 기본 동작이고, `.get()`은 상위 클래스로부터 `Override`한 메서드이다.
두 가지 동작이 달라 혼란스러울 수 있다!

**테오**: protected 메소드에 대해 어떻게 생각하세요? 저는 이 아이템을 읽고 나서 protected가 추상화 레벨을 파괴하는 주범으로 생각되는 것 같아요.

## 아이템 19
**헙크**: 추상 클래스에서 메서드 바디를 구성해 하위 클래스에서 사용할 수 있도록 제공하려고할 때, 메서드 레벨에 `final`을 붙여야만 하는가?

- 지토:        
![](https://user-images.githubusercontent.com/57691173/227140323-59993aee-ec61-4a61-ab8e-1269e71285ea.png)   
`final` 안붙이고 하위 클래스에서 재정의하는 꼼수를 부려봤는데 이런 피드백을 받은 것으로 보아 이러는 것을 방지하기 위해서 `final`을 붙이는 것이 좋을 것 같습니다. 
- **이리내**: 저도 지토와 같은 꼼수를 부려서 지토와 유사한(?) 피드백을 받았는데요. 추상클래스에서 바디를 구성하고, 이를 하위 클래스에서 오버라이딩으로 메서드를 재정의하게된다면, 추상클래스에서 `완전히 구현되지 않은 상태를 구현됬다고 뻥치는 것`으로 보인다는 느낌의 피드백을 받았습니다. `추상`클래스라는 닉값을 하려면 자식클래스에 따라 동작이 달라질 가능성이 있는 메서드들은 추상메서드로, 그게 아닌 메서드는 final로 선언하는 게 좋을 것 같아요!

**깃짱**: p.125 `상속용 클래스의 생성자는 Override 가능한 메서드를 호출해서는 안된다.`   
![image](https://user-images.githubusercontent.com/107979804/227126292-7306bdce-7ee6-4a15-976d-ffd0b42acc4d.png)


실행 결과가 이렇게 나왔습니다.   


![image](https://user-images.githubusercontent.com/107979804/227126409-bea25ba8-9071-4fdf-91ed-54b0382756cf.png)



저는 출력 결과가 
```
Super 클래스
Sub 클래스
2023-03-23T06:52:25.039807200Z
``` 

일 것이라고 예상했는데, 이 출력 메세지를 본다면,    
`Sub` 클래스의 메서드로 override 된다 => Super 클래스의 생성자 호출 => Sub 클래스의 생성자 호출   
이런 식으로 메서드가 호출되는 걸까요?
- 지토: 그런거 같습니다! `Sub` 클래스를 `new` 키워드를 통해 호출하다보니 `Super` 클래스의 생성자의 `overrideMe()`는 `Sub.overrideMe()`가 될 수 밖에 없다 보니 두 번 호출되는 느낌?인 것 같습니다!

## 아이템 20

**지토**: 블랙잭 미션때도 그렇고 지금 체스 미션때도 그렇고 저는 항상 상속을 사용하면 피를 보게 되는 것 같습니다...이번 파트를 읽어보니 상속을 사용하려면 고려해야 할 사항이 많은 것 같은데, 차라리 미션에서는 상속을 후순위로 미뤄두는게 나을까요?

## 아이템 21

## 아이템 22

## 아이템 23

## 아이템 24

## 아이템 25
