- [아이템15](#아이템15)
- [아이템16](#아이템16)
- [아이템17](#아이템17)
- [아이템18](#아이템18)
- [아이템19](#아이템19)
- [아이템20](#아이템20)
- [아이템21](#아이템21)
- [아이템22](#아이템22)
- [아이템23](#아이템23)
- [아이템24](#아이템24)
- [아이템25](#아이템25)

## 아이템 15

**쥬니**: 이 전에도 나왔던 이야기 같은데, 서로 다른 클래스에서 동일한 상수를 사용한다면 각각에서 `private static`으로 관리하시는지, 하나의 클래스에서 `public static`으로관리하시는지 궁금합니다. 혹은 `enum`을 사용하시기도 하겠죠 !?  
- **깃짱**: 저는 각각 관리합니다. 이 [질문에 대한 답을 한 리뷰](https://github.com/woowacourse/java-chess/pull/516#issuecomment-1478089090)를 염탐중에 봐서, 첨부할게요
        ![image](https://user-images.githubusercontent.com/107979804/227103421-409f27e9-6334-4c91-a637-2fcc0fee3da3.png)
        

## 아이템 16

## 아이템 17
**쥬니**: 아래 코드의 결과는 무엇일까요 ?
```java
public class Item17 {
    public static void main(String[] args) {
        StringBuilder sb = new StringBuilder();

        sb.append("test");

        String str1 = sb.toString();
        String str2 = "test";

        System.out.println("str1 == str2 ? " + (str1 == str2)); // true ? false ?
    }
}
```

- **지토**: false가 나올 것 같습니다!
- **깃짱**: 올 지토 돌려보셨나요..?    

![image](https://user-images.githubusercontent.com/107979804/227104006-787fb3ac-59d0-49aa-96d1-d3daf7f08974.png)

왜 이런걸까요...? `StringBuilder`를 생성했을 때 `706`이었다가 `.toString()`을 통해서 `str1`로 만들 때 `834`가 되었고, `str2`는 `835`네요
`StringBuilder.toString()`을 뜯어보면

```java
    @Override
    @HotSpotIntrinsicCandidate
    public String toString() {
        // Create a copy, don't share the array
        return isLatin1() ? StringLatin1.newString(value, 0, count)
                          : StringUTF16.newString(value, 0, count);
    }
```

이렇게 생겼고,
여기서 `StringLatin1.newString()`을 보면

```java
   public static String newString(byte[] val, int index, int len) {
        return new String(Arrays.copyOfRange(val, index, index + len),
                          LATIN1);
    }
```

이렇게 생겼네요...! 
`new String()`으로 생성자를 새로 호출하기 때문에 다른 주소값을 받게 되나봅니다.

**헙크**: JMM이란 무엇일까? 멀티 스레드 프로그래밍에서 어떤 것을 주의해야 할까?

## 아이템 18

**쥬니**: 상속이 `콜백` 프레임워크와 어울리지 않는다는 예시는 [이곳](https://stackoverflow.com/questions/28254116/wrapper-classes-are-not-suited-for-callback-frameworks)을 참고하세요 !

**깃짱**: p.120 이 페이지에서 `Properties` 클래스는 `Hashtable`을 컴포지션으로 기능을 위임했다면 좋았을 텐데, 불필요하게 `Hashtable`을 상속해 내부 구현을 불필요하게 노출했다고 하고 있다. `Properties의 인스턴스인 p가 있을 때, p.getProperty(key)와 p.get(key)의 결과가 다를 수 있다`

여기 코드를 `Properties` 클래스에 들어가서 직접 가져왔다.

```java
    public String getProperty(String key) {
        Object oval = map.get(key);
        String sval = (oval instanceof String) ? (String)oval : null;
        Properties defaults;
        return ((sval == null) && ((defaults = this.defaults) != null)) ? defaults.getProperty(key) : sval;
    }
    
        @Override
    public Object get(Object key) {
        return map.get(key);
    }
```

여기서 `.getProperty()`는 기본 동작이고, `.get()`은 상위 클래스로부터 `Override`한 메서드이다.
두 가지 동작이 달라 혼란스러울 수 있다!

## 아이템 19
**헙크**: 추상 클래스에서 메서드 바디를 구성해 하위 클래스에서 사용할 수 있도록 제공하려고할 때, 메서드 레벨에 `final`을 붙여야만 하는가?

**깃짱**: p.125 `상속용 클래스의 생성자는 Override 가능한 메서드를 호출해서는 안된다.`
![image](https://user-images.githubusercontent.com/107979804/227126292-7306bdce-7ee6-4a15-976d-ffd0b42acc4d.png)



## 아이템 20

## 아이템 21

## 아이템 22

## 아이템 23

## 아이템 24

## 아이템 25
