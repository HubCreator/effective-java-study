- [아이템69](#아이템69)
- [아이템70](#아이템70)
- [아이템71](#아이템71)
- [아이템72](#아이템72)
- [아이템73](#아이템73)
- [아이템74](#아이템74)

## 아이템69
**민트**: 387 페이지에 따르면, `코드를 try-catch 블록 안에 넣으면 JVM이 적용할 수 있는 최적화가 제한된다.`고 말합니다.
try-catch 문 안의 코드는 왜 JVM의 최적화가 제한될까요?

**테오**: 이해한 바에 따르면, 예외는 가능한 발생하지 않는 편이 성능에 좋습니다(= try-catch 블록이 없는 것이 좋음).
그러면 우리가 미션에서 접하는 예외는 정말 예외 상황일까요? 재입력을 받는 것 까지 시스템의 일부라고 볼 수 있지 않을까요?
그렇다면 책에서 명시한 대로 Optional과 상태 검사 메서드를 조합해 예외를 전혀 사용하지 않을 수도 있지 않을까요?
  - **깃짱**: 사용자의 잘못된 입력에 대해 처리하는 표준 예외 `IllegalArgumentException`이 있는데, 가짜 에외는 아닐 것 같아요! `책에서 명시한 대로 Optional과 상태 검사 메서드를 조합해 예외를 전혀 사용하지 않을 수도 있지 않을까` 이 부분은 가능할 것 같아요! 테오가 한번 자동차 경주 미션을 그렇게 리팩토링 해주시겠어요?!?!?!!?!?! 
  - **지토**: 저는 예외가 애플리케이션에서 비정상적인 흐름이라고 생각합니다! 설계에 따라 어떤 상황이 예외인지 결정할 수 있기 때문에 예외라고 볼 수 있다고 생각합니다! 다만 이런 관점에서 보자면, 테오가 말씀하신 대로 동일한 상황에 대해 예외 상황이 아닌 자연스러운 흐름이라고 볼 수도 있을 것 같습니다!   
 - **이리내**: 재입력받는 기능을 추가하지 않는다면 IllegalArguementException을 던지며 프로그램이 바로 종료됩니다.(이때는 try-catch가 필요없죠) 하지만 저희가 잘못된 입력값들 이 들어왔을 때 재입력을 받고자 한다면 일반적으로 try-catch를 사용해 예외가 catch되는 상황이 발생했을 경우 재귀적으로 메소드를 호출하게 됩니다.(제 개인적인 생각으론 unchecked exception을 checked exception 처럼 쓰는 것으로 느껴집니다.) 테오님 말씀대로 try-catch는 없이 재입력을 꼭!! 받고자 한다면 IllegalArgumentException을 반환하지 않고, 빈 옵셔널과 상태 검사 메서드를 조합해야 할 것 같습니다!    

**깃짱**: 저는 한번도 예외를 흐름 제어용으로 쓴 적이 없는데, 한 적도 없는걸 너무 강하게 하지 말라고 말하니 더 오기가 생기는 것 같아요ㅠ

**헙크**: 제가 이해한 바로는, 예외를 흐름 제어용으로 쓰지 말라는 말은 `if`문이나 반복문의 `break` 등을 사용하기 싫어서 일부러 예외를 발생시키고, 이를 `catch`하여 코드의 전체적인 흐름을 제어하는 일을 하지 말라는 것 같습니다.

**쥬니**: 책에서 '성능이 중요한 상황에서 상태 검사 메서드가 상태 의존적 메서드의 작업 일부를 중복 수행한다면 옵셔널이나 특정 값을 선택한다. 라는 문장이 있는데요.
상태 검사 메서드가 상태 의존적 메서드의 작업을 중복 수행하는 경우가 있을까요 ?

**지토**: `특정 상태에서만 호출할 수 있는 상태 의존적인 메소드를 제공하는 클래스는 상태 검사 메소드도 같이 제공해야 한다`는 어떤 의미일까요?
  - **이리내**: 말그대로 `특정 상태`에서만 메소드가 정상 작동하기 때문에, 정상 작동할 수 있는 `특정 상태`를 만족하는지 상태검사 메소드를 통해 먼저 확인 후에, 조건이 만족할 때만 상태 의존적 메소드를 실행할 수 있어야 한다는 것 아닐까요? 

## 아이템70

**깃짱**: 저는 호출하는 쪽에서 복구할 수 있는 상황이면 Compiletime Exception, 아니면 Runtime Exception을 던지라고 이해했습니다. 사실 이거에 대한 구분은 잘 가지 않아서 당분간은_ 확실하지 않다면 Runtime Exception을 사용해라_만 지킬 것 같아요 ㅎㅎ...

**헙크**: 예를들어 사용자가 웹 사이트에 로그인한다고 가정했을 때, 지문 인식을 한다고 가정해봅시다. 지문인식이 실패하면 비즈니스적으로 세 번 다시 시도할 수 있다고 해봅시다. 이처럼 비즈니스적으로 실패가 예견되어 있고, 애플리케이션 실행 중에 실패를 정확히 잡아 다시 시도할 수 있도록 하는 상황이라면 check exception을 사용합니다. 반면에 로그인을 처리하는 과정에서 DB에 SQL문을 날렸는데 개발자가 `String sql = "select allll from User where userId=?"`로 잘못 코딩했다 칩시다. 이런 상황이라면 개발자가 `allll`을 바꾸지 않는 이상 애플리케이션 실행 중에 우리의 코드가 자체적으로 sql문을 고쳐주진 못하니, 이럴 때는 uncheck exception을 사용하고 `catch`를 하려고 시도조차 하면 안됩니다. 그저 예외를 발생시키고 종료하는 것이 최선이기 때문입니다. 만약 이곳에서 check exception을 사용하면 최상위 호출부까지 `throws`를 명시해주어야 해서, 모든 계층이 더러워집니다.
  - **이리내**: 지문인식에서 실패해서 세번 다시 시도하는 것과, 사다리 미션에서 잘못된 입력을 해서 세번 다시 시도하는 것은 차이가 무엇이길래 전자는 checked, 후자는 unchecked가 되는 것인가요? 저는 아직 차이를 잘 모르겠습니다... 
  - **지토**: 동의합니다! `sql`을 실행하는 외부 프로그램에 의해 발생하는 예외이므로 `throws`로 던지는 경우 해당 예외를 처리할 수도, 신경쓸 필요도 없는 다른 객체에서도 `SqlException`에 대한 의존성이 추가되어 좋지 않을 것 같습니다!

**하디**: 다들 checked / unchecked를 사용하는 상황이 잘 이해가 되나요? 저는 책에서 말한 복구할 수 있는 예외는 checked, 프로그래밍 문제는 unchecked라는 말이 막 와닫지는 않네요.
그렇다면 IOException과 SqlException이 checked인 이유는 무엇인가요? 다른 예외들이 unchecked로 분류된 이유는 무엇이라고 생각하시나요 ?
  - **지토**: 저는 `checked`의 복구할 수 있는 예외를 `외부 요인으로 인해 애플리케이션이 변경될 수 있고, 이러한 상황을 애플리케이션의 코드 변경 없이 정상적인 흐름으로 복구할 수 있는 예외`라고 이해했습니다! `SqlException`을 예시로 든다면 `DB` 서버가 갑자기 1분동안 죽어버렸다면, 1분동안은 `SqlException`이 발생하겠지만 그 이후에는 정상적인 흐름으로 바뀔테니, `예외 상황에서 정상적인 흐름으로 복구`라고 이해했습니다! `NullPointerException` 관점으로 보자면, 데이터를 잘못 세팅한 경우 아무리 기다려도 `NPE`가 해결되지 않을 것입니다! 애플리케이션의 코드 변경 없이 재실행하더라도 동일한 환경에서는 항상 동일한 `NPE`가 발생할 것입니다! 그러므로 애플리케이션의 코드 없이는 특정 상황에 발생하는 예외를 해결할 수 없으므로 애플리케이션의 정상적인 흐름을 복구할 수 없기 때문에 `unchecked`라고 이해했습니다!

**지토**: 왜 런타임 예외를 잡으면 득보다 실이 많을까요?

**레오**: checked예외가 발생한 경우 프로그램을 정상적으로 빌드하기 위해선 어디선간 try...catch를 이용해 처리를 해야되는데, 이 위치를 정하는 기준이 있으신가요? 저희 미션에서는 controller에서 하는 분들도 있고, domain단에서 하는 분들도 계신걸 봤는데 다들 어디서 try...catch를 사용하시는지 궁금합니다!

## 아이템71

**깃짱**: 검사 예외는 원래 잘 사용하지 않았었는데, 혹시 검사 예외 다들 쓰셨나요???

**민트**: 저는 검사 예외를 던지는 메서드를 스트림 안에서 사용함으로써 예외를 처리해야 했던 경험이 없습니다! 여러분들은 있으신가요? 자주 사용하는 메소드 중, 검사 예외를 던지는 메소드로는 어떤 것들이 있을까요?

**테오**: 저는 지금까지 검사 예외를 본 적이 없는 것 같아요! catch를 강제해야 할 정도로 중요도가 큰 API를 아직 사용해보지 못해서 그런건가 싶기도 하네요..!
  
**하디**: `검사 예외를 회피하는 가장 쉬운 방법은 적절한 결과 타입을 담은 옵셔널을 반환하는 것이다.(394p)` checked exception대신 이렇게 옵셔널을 반환해야하는 경우가 무엇이 있을까요 ?
  - **지토**: 해당 `API`를 사용하는 클라이언트에게 예외 처리를 온전히 위임하고자 할 때 사용하지 않을까 싶습니다!

**이리내**: 저는 Mysql DB랑 커넥션을 연결할 때 SqlException 처리를 강제로 해야했던 경험이 있었는데요, `java.sql.Exception: No suitable driver found for jdbc:mysql://localhost:13306/TEST_DB` 이런 비슷한 문구들을 본 적이 있어요 근데 글쎄요 저는 이게 재시도로 복구 가능한 상황인지는 잘 모르겠네요, 구글링을 해보니 SqlException은 너무 포괄적인 예외이고, 실제로 복구 불가능한 상황도 많다는 둥 SqlException은 사라졌다는 둥, checked exception은 활용도가 떨어진다는 둥 하면서 checked exception이 발생하는 상황에는 이를 더 구체적인 unchecked exception으로 전환해서 던져준다고 하네요.(아이템73의 아이템 번역을 응용하는 느낌이 드네요) 덧붙이자면 코틀린은 아예 checked exception을 제공하지 않는다고합니다. checked exception은 구닥다리인 것이 아닐까요?
  - **지토**: 저도 구닥다리라고 생각합니다! 결국 `Checked Exception`을 사용하면 의존성도 높아지고 사용성도 떨어지니까요!

**지토**: `상태 검사 메소드의 단점은 클라이언트가 이 메소드를 알아야 한다는 점이다.`라고 언급되어 있는데, 메소드를 알아야 한다는 것이 왜 단점이 되는 것일까요?

## 아이템72
**테오**: 직렬화를 이유로 커스텀 예외를 사용하지 말아야 한다고 주장하는데, 직렬화에서 어떤 문제가 발생할까요?
  - **지토**: 기본적으로 예외는 모두 직렬화가 가능하기 때문에, 이를 확장한 커스텀 예외도 직렬화가 가능하므로 직렬화의 범위를 잘 지정하지 않는다면 개발자의 의도와는 달리 자세한 상황을 처리하기 위해 구현한 수 많은 커스텀 예외까지 같이 직렬화가 되어 효율에 문제가 발생할 것 같습니다!

**깃짱**: 표준 예외를 사용하자와 커스텀 예외를 사용하자 파가 아주 크게 갈린다는데, 여러분은 어디 파인가요? 저는 표준에외 파에요!
  - **이리내**: 저도 있는거 잘쓰자..! 표준예외 ㅎㅎ..
  - **지토**: 저는 커스텀 예외를 선호합니다! 리뷰어분이 커스텀 예외에 대해 피드백을 주신다면 바꾸겠지만요!

**쥬니**: 
```java
List<String> targetList = List.of("aa","bb","cc","dd");
 
for(target : targetList){
  if("aa".equals(target){
    targetList.remove(target);
  }
}
```
위 상황에서 IndexOutOfBoundsException이 아닌 ConcurrentModificationException이 발생하는 이유는 무엇일까요 ?
  - **지토**: `IndexOutOfBoundsException`은 인덱스 관련 예외인데 예제 코드에서는 인덱스를 활용하는 구간이 없기 때문에 발생하지 않은 것 같습니다! 자바 API 살펴보니 `ConcurrentModificationException`은 동시 수정이 감지되었을 때 발생한다고 언급하며 `다른 스레드가 컬렉션을 반복하는 동안 한 스레드가 컬렉션을 수정하는 것은 일반적으로 허용되지 않는다.`인 상황을 예시로 제시하고 있습니다! `for문`을 돌면서 `for문`을 돌고 있는 컬렉션의 요소를 삭제한다고 해도 이미 실행되고 있는 `for문`은 이를 감지하지 못하기 때문에 발생하는 것 같습니다!

**헙크**: fail-fast라는 개념은 무엇일까? Objects.requireNonNull은 NPE와 관련된 개념인데 언제 어떻게 사용하면 될까?
  - **지토**: `fail-fast`은 컬렉션에서 동시 수정이 일어났는지 감시해 `ConcurrentModificationException` 예외가 발생하는 흐름인지 확인하기 위해 사용된다고 합니다! `Objects.requireNonNull()`의 경우 `API` 보니 주로 파라미터의 `Null` 검증을 위해 사용되며, `Null`이면 내부적으로 `NPE`가 발생하고 `Null`이 아니라면 파라미터로 넘긴 인자를 그대로 반환한다고 합니다!

**지토**: `IllegalStateException`인 흐름에서 해당 예외가 발생하는 경우가 무조건 `null` 때문이라면 발생하는 예외를 `NullPointerException`으로 무조건 변경해야 할까요?

## 아이템73
**깃짱**: 상황에 맞는 표준 예외를 던진다면, 상위에서는 `RuntimeException`으로 catch하게 될까요? 상위에서 `Exception`으로 catch하게 된다면 어떤 예외도 다 처리할 수 있게 될텐데, 예상치 못한 예외까지 전부 퉁쳐서 해결하게 되어서 문제가 될 것 같아요. 이럴 경우에는 어떻게 해결할 수 있을까요?
  - **지토**: `RuntimeException`으로 잡히게 될 것 같습니다! `getCause()`로 구체적인 예외를 가져온다거나, `RuntimeException`을 `catch`하는 블록의 상위에 조금 더 구체적인 예외를 잡는다거나 하면 되지 않을까 싶습니다!

**이리내**: 책에는 `가능하면 저수준의 메서드가 반드시 성공하도록 하여 아래 계층에서는 예외가 발생하지 않도록 하는 것이 최선이다. 때론 상위 계층 메서드의 매개변수 값을 아래 계층 메서드로 건네기 전에 미리 검사하는 방법으로 이 목적을 달성할 수 있다`라고 써있습니다. 다음 코드는 제 사다리타기 미션 중 `List<boolean> points`를 필드로 갖는 `Row` 클래스에 속한 메서드인데요, 저는 이 메서드에 `point` 값을 넘기기 전에 인덱스를 넘어가는 값은 넘기지 않도록 하였습니다. 반면, 아래의 메서드 안에서 인덱스 에러를 예외처리 해주는 것이 좋을 것 같다는 의견들도 있었는데요, 다들 어느 방법을 선호하시는 편인가요?
```
 public boolean isCurrentPointHasLine(int point) {
        return points.get(point);
    }
```

**민트**: 예외 연쇄를 3번 이상 쌓을 수 있을까요?

**테오**: 예외 연쇄를 사용하면 단점이 어떤 것이 있을까요? 지금 생각나는 건 `예외처리 비용이 비싸다` 정도네요!

**헙크**: 예외가 발생하면 stack trace를 터미널에서 볼 수 있는데, `catch`문을 작성하면 왜 발생하지 않을까? stack trace는 어디로 갔을까? stack trace란 무엇일까?

**지토**: 예외 번역의 예시로는 무엇이 있을까요?    

**레오**: 예외 번역,연쇄를 이용하기 위해서는 예외를 재정의 하는것이 필수일까요?

## 아이템74
**이리내**: 문서화라는게 무엇을 말하는 걸까요? 검색해보니 메소드 위에 `/* */` 주석안에 태그를 넣어놓는 예시가 많이 나오는데 이걸 문서화라 말하는 걸까요?

- **테오**: 주석 맞는 것 같아요! 요즘에는 여기서 말한 문서화처럼 주석을 사용해도 된다는 파의 주장이 점점 커지고 있다고 하더라구요. 다들 어떻게 생각하시나요?

**지토**: 문서화 대신 `RuntimeException`이 발생하는 것을 강조(클라이언트에서 확인 가능)하기 위해 `throws`로 명시하는 것은 어떻게 생각하시나요? 

## 아이템75

**깃짱**: 사다리 리뷰에서, 예외 메세지는 `toString` 메서드 재정의처럼 개발자들끼리 편하자고 하는 것인데, 뭐하러 상수화를 하냐는 피드백을 받았어요. 사실 많은 분들이 예외 메세지까지 상수 처리를 하고 있기도 하고요! 저 피드백을 받았을 당시까지는 `일리는 있는데 리뷰어 뇌피셜인가` 생각했는데, 이 아이템을 읽어보니...! 앞으로 저는 상수 처리 하지 않고 그대로 `throw new IllegalArgumentException("여기그대로둘거임");`으로 만들어야겠다는 생각이 들었습니다. 다들 예외메세지 상수화 하시나요? 하신다면 어떤 의도로 하시나요? 1. 하드코딩이라 생각해서 2. `public` 상수로 두고 예외메세지까지 `hasMessage`로 테스트 코드에서 테스트하고 싶어서 => 이 부분에 대해서도 리뷰어는 그닥 추천하지 않았습니다 이유는 차차 알아보죠...

**헙크** : 예외 메시지는 누구 보라고 작성할까?

**지토** : 예외 메세지에 실패 관련 정보를 상세하게 표현하고자 하는 상황이라고 가정하겠습니다. 일반적인 자바 API는 대부분 메세지만 받고 `IndexOutofBoundsException`는 정수 인덱스만 받는다고 책에서 언급이 되었습니다. 그렇다면 일반적인 예외 발생 상황에서 실패 관련 정보를 도메인에 맞춰 상세하기 작성하기 위해서면 도메인 영역에서 구체적인 메세지를 작성해주거나, 커스텀 예외를 만드는 방법밖에는 떠오르지 않는데 다른 방법이 있을까요?

**민트** : `IndexOutOfBoundsException`의 생성자로 정수 인덱스만 전달했을 떄, 해당 Exception은 어떤 메시지를 가지게 될까요? 확인해보니 `IndexOutOfBoundsException` 클래스 내에 다음 이미지와 같이 정의되어 있네요.
<img width="391" alt="image" src="https://user-images.githubusercontent.com/71512749/223365695-f0a2adee-f290-4ba7-a57f-c7c80f2361b6.png">


## 아이템76

**깃짱**: 이번 아이템은 유난히 좀 당장 쓸모있는 내용이 많은 것 같아요. 메서드가 실패해도 객체가 호출 전 상태를 유지하기 위해서 객체를 불변객체로 만드는 것은 무슨 행동일까요? 저는 어차피 변할 수 없게 만든 객체를 변화시키다가 예외가 발생해도 아 괜찮아~ 하는건 약간 허튼 짓 같은데...(?) 어떻게 생각하시나요??   
저는 `메서드가 실패해도 객체의 상태는 그대로` 하려면 책에서 말한대로 어딘가에 복사하거나, 실패할 것 같은 부분을 상태 변화 이전에 해버리거나 하는 등등 상태를 변화시키기 이전에 먼저 테스트해보는 등등 먼저 해봐야 한다고 이해했습니다.

**헙크** : 불변 객체 다들 많이 사용하시나요?? 불변 객체의 단점은 무엇일까요? 항상 사용하는 것이 좋을까요?


## 아이템77

**깃짱**: `catch`문을 만들어놓고, 아무 일도 하지 않고 있으면 IDE에서 `Exception`의 파라미터 내 이름을 `ignored`로 바꾸라고 제안해주는거 아시나요? 
  - 지토 : ? 이건 몰랐네요 역시 인텔리제이...

**지토**: 예외를 무시할만한 상황이 뭐가 또 추가로 있을까요? `OutOfMemoryError`와 같이 절대 복구할 수 없고, 애플리케이션 자체적으로 해결하려고 해서도 안될 예외? `Stream` 사용 시 정상적인 연산을 마치기 위해서? 테스트 코드에서 리플렉션과 같이 예외가 발생하지만 굳이 해결하지 않아도 될 때? 
