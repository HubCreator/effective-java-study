- [아이템69](#아이템69)
- [아이템70](#아이템70)
- [아이템71](#아이템71)
- [아이템72](#아이템72)
- [아이템73](#아이템73)
- [아이템74](#아이템74)

## 아이템69
**민트** : 387 페이지에 따르면, `코드를 try-catch 블록 안에 넣으면 JVM이 적용할 수 있는 최적화가 제한된다.`고 말합니다.
try-catch 문 안의 코드는 왜 JVM의 최적화가 제한될까요?

**테오**: 이해한 바에 따르면, 예외는 가능한 발생하지 않는 편이 성능에 좋습니다(= try-catch 블록이 없는 것이 좋음).
그러면 우리가 미션에서 접하는 예외는 정말 예외 상황일까요? 재입력을 받는 것 까지 시스템의 일부라고 볼 수 있지 않을까요?
그렇다면 책에서 명시한 대로 Optional과 상태 검사 메서드를 조합해 예외를 전혀 사용하지 않을 수도 있지 않을까요?
  - **깃짱**: 사용자의 잘못된 입력에 대해 처리하는 표준 예외 `IllegalArgumentException`이 있는데, 가짜 에외는 아닐 것 같아요! `책에서 명시한 대로 Optional과 상태 검사 메서드를 조합해 예외를 전혀 사용하지 않을 수도 있지 않을까` 이 부분은 가능할 것 같아요! 테오가 한번 자동차 경주 미션을 그렇게 리팩토링 해주시겠어요?!?!?!!?!?! 

**깃짱**: 저는 한번도 예외를 흐름 제어용으로 쓴 적이 없는데, 한 적도 없는걸 너무 강하게 하지 말라고 말하니 더 오기가 생기는 것 같아요ㅠ

## 아이템70

**깃짱**: 저는 호출하는 쪽에서 복구할 수 있는 상황이면 Compiletime Exception, 아니면 Runtime Exception을 던지라고 이해했습니다. 사실 이거에 대한 구분은 잘 가지 않아서 당분간은_ 확실하지 않다면 Runtime Exception을 사용해라_만 지킬 것 같아요 ㅎㅎ...

## 아이템71

## 아이템72
**테오**: 직렬화를 이유로 커스텀 예외를 사용하지 말아야 한다고 주장하는데, 직렬화에서 어떤 문제가 발생할까요?


## 아이템73

## 아이템74
